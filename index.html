<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Ontologías</title>

		<meta name="description" content="Ontologías">
		<meta name="author" content="Miguel Expósito Martín">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            # semántica
                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                           - Redes semánticas
                           - Minería de textos y minería web
                           - **Ontologías**
                           - Linked Data
                           - Análisis de redes complejas
                        </script>
                    </section>

                </section>
                <section>
				<section data-id="1" data-markdown>
					<script type="text/template">
					# Ontologías

					</script>
				</section>
                <section data-id="1" data-markdown>
                    <script type="text/template">
                        ### Ontologías
                        - Introducción a la Web Semántica
                        - Introducción a RDF
                        - Introducción a Ontologías
                        - RDFs
                        - OWL
                        - SKOS


                    </script>
                </section>
                </section>
                <section>
                        <section data-id="1" data-markdown>
                                <script type="text/template">
                                                        ## La Web Semántica
                                                                                
                                                        ![Portada de Scientific American 2001](./img/semantic_web.png)<!-- .element height="40%" width="40%" -->
                                                                      
                                                        </script>
                        </section>
                        <section data-id="1" data-markdown>
                                <script type="text/template">
                                        ### y linked open data
                                        [![Parte de la nube de LOD](./img/lod-datasets_2009-07-14_cropped.png)](https://lod-cloud.net/)

                                </script>
                        </section>
               
                <section data-id="1" data-markdown>
                        <script type="text/template">
                                ### ¿en qué se basan?

                                RDF + XML + ontologías <!-- .element: class="fragment" data-fragment-index="1" -->

                                **sujeto - predicado - objeto** <!-- .element: class="fragment" data-fragment-index="2" -->

                                    <http://example.org/bob#me>
                                    <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
                                    <http://xmlns.com/foaf/0.1/Person> .
                                <!-- .element: class="fragment" data-fragment-index="3" -->

                                ¡y SPARQL! <!-- .element: class="fragment" data-fragment-index="4" -->
                        </script>
                </section>
                <section data-id="1" data-markdown>
                        <script type="text/template">
                                ### ¿cómo es una aplicación semántica?
                                ![Arquitectura aplicación semántica](./img/despliegue.png)
                        </script>
                </section>
        </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # Introducción a RDF

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Qué es RDF?

                ><!-- .element: class="fragment" data-fragment-index="1" --> Un marco de trabajo para expresar información sobre recursos.<!-- .element: class="fragment" data-fragment-index="1" -->

                documentos, personas, objetos físicos y/o abstractos...<!-- .element: class="fragment" data-fragment-index="2" -->

                - información en la web necesita ser procesada por aplicaciones<!-- .element: class="fragment" data-fragment-index="3" -->
                - RDF ofrece un marco común sin pérdida de significado<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                 ## ¿Para qué RDF?
                 - para añadir información legible para motores de búsqueda<!-- .element: class="fragment" data-fragment-index="1" -->
                 - para enriquecer un dataset <!-- .element: class="fragment" data-fragment-index="2" -->[enlazándolo](http://lod-cloud.net/)<!-- .element: class="fragment" data-fragment-index="2" --> con datasets de terceros<!-- .element: class="fragment" data-fragment-index="2" -->
                 - para entrelazar feeds de APIs, facilitando su descubrimiento<!-- .element: class="fragment" data-fragment-index="3" -->
                 - para construir agregaciones de datos sobre determinados temas<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Para qué RDF?
                - para proporcionar un estándar de intercambio de datos entre BBDDs<!-- .element: class="fragment" data-fragment-index="1" -->
                - para permitir consultas cruzadas a datasets de una organización<!-- .element: class="fragment" data-fragment-index="2" -->
                - para enriquecer, describir y contextualizar los datos<!-- .element: class="fragment" data-fragment-index="3" -->
                - para fomentar nuevas asociaciones entre datasets<!-- .element: class="fragment" data-fragment-index="4" -->


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Y el modelo relacional?
                - una tabla es fácil de mostrar, ordenar y editar<!-- .element: class="fragment" data-fragment-index="1" -->
                - su semántica está en las filas y columnas de sus tablas<!-- .element: class="fragment" data-fragment-index="2" -->
                - una BDR permite cruzar varias tablas de forma estándar<!-- .element: class="fragment" data-fragment-index="3" -->
                - evolucionar los esquemas es complejo:<!-- .element: class="fragment" data-fragment-index="4" -->

                datos + consultas<!-- .element: class="fragment" data-fragment-index="4" -->



                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Y el modelo relacional?
                - además, los esquemas se pueden volver tremendamente complicados<!-- .element: class="fragment" data-fragment-index="1" -->

                soluciones: procedimientos almacenados y ORMs<!-- .element: class="fragment" data-fragment-index="2" -->

                #### a veces, es necesario modelar para lo inesperado: flexibilidad<!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### un esquema complicado
                            ![Esquema complejo](./img/data_model_hell.png)
                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### comparativa de paradigmas
                            |Mundo Relacional|Mundo Semántico|
                            |----------------|----------------|
                            |Registro de tabla|Nodo RDF|
                            |Columna de tabla|RDF property Type|
                            |Celda de tabla|Valor|
                            |Consulta SQL|Consulta SPARQL|
                            |Modelo de datos|Ontología|
                        </script>
                    </section>

                    <section data-id="1" data-markdown style="font-size:35px">
                        <script type="text/template">
                            ### almacenes RDF vs BDR
                            - **Flexibilidad:** su esquema flexible permite realizar cambios sin paradas ni rediseños, cosa que no ocurre con una base de datos relacional.
                            - **Estandarización:** el nivel de estandarización de RDF y SPARQL es mucho mayor que el de SQL. Es prácticamente inmediato sustituir un almacén de tripletas por otro, mientras que en el caso de las bases de datos relacionales es necesario tener en cuenta los distintos dialectos e implementaciones de SQL según el fabricante.
                            - **Expresividad:** es mucho más sencillo modelar datos complejos y con elevado número de relaciones entre ellos en RDF que en SQL. Ocurre al contrario si los datos son de naturaleza tabular, naturalmente.
                        </script>
                    </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### almacenes RDF vs BDR
                            no todo son ventajas...
                            - **Madurez:** las bases de datos relacionales son mucho más maduras y presentan más funcionalidades que los almacenes de ternas.
                            - **Coste de almacenamiento**: El coste por unidad de información almacenada en un almacén de ternas es mucho mayor que el de una base de datos relacional, lo cual puede ser crítico si se están tratando grandes volúmenes de datos.
                        </script>
                    </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo de datos RDF

                - RDF permite hacer declaraciones sobre recursos.<!-- .element: class="fragment" data-fragment-index="1" -->
                - El formato de una declaración es sencillo:<!-- .element: class="fragment" data-fragment-index="2" -->

                **sujeto + predicado + objeto**<!-- .element: class="fragment" data-fragment-index="3" -->

                - El predicado representa la naturaleza de la relación<!-- .element: class="fragment" data-fragment-index="4" -->
                - Las declaraciones RDF se denominan tripletas<!-- .element: class="fragment" data-fragment-index="5" -->


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo informal de tripletas

                        <Bob> <is a> <person>.
                        <Bob> <is a friend of> <Alice>.
                        <Bob> <is born on> <the 4th of July 1990>.
                        <Bob> <is interested in> <the Mona Lisa>.
                        <the Mona Lisa> <was created by> <Leonardo da Vinci>.
                        <the video 'La Joconde à Washington'> <is about> <the Mona Lisa>.

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo informal de tripletas

                ![Grafo de tripletas](./img/example-graph.jpg)<!-- .element: height="75%" width="75%"-->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## IRIs, URIs, URLs
                - URI: identifica un recurso físico o abstracto<!-- .element: class="fragment" data-fragment-index="1" -->
                - IRI: como la URI, pero incorpora UTF-8<!-- .element: class="fragment" data-fragment-index="2" -->
                - URL: una URI que, además de identificar, proporciona una forma de localizar el recurso a través de su mecanismo de acceso primario<!-- .element: class="fragment" data-fragment-index="3" -->

                http://dbpedia.org/resource/Leonardo_da_Vinci<!-- .element: class="fragment" data-fragment-index="4" -->

                **son identificadores únicos (fuertes)**<!-- .element: class="fragment" data-fragment-index="5" -->


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## IRIs, URIs, URLs
                Es común acortar los URIs asignando un espacio de nombres a su base:

                http://www.w3.org/1999/02/22-rdf-syntax-ns#type

                rdf = http://www.w3.org/1999/02/22-rdf-syntax-ns#

                **rdf:type**


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## literales
                valores básicos que no son IRIs (strings, dates...)<!-- .element: class="fragment" data-fragment-index="1" -->

                Muchos <!-- .element: class="fragment" data-fragment-index="2" -->[tipos de datos](https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-Datatypes)<!-- .element: class="fragment" data-fragment-index="2" --> provienen de XML Schema<!-- .element: class="fragment" data-fragment-index="2" -->


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## blank nodes

                - A veces es útil representar un recurso sin usar un identificador.<!-- .element: class="fragment" data-fragment-index="1" -->
                - Se asemejan a variables en álgebra: representan algo cuyo valor se desconoce.<!-- .element: class="fragment" data-fragment-index="2" -->
                - Pueden aparecer en las posiciones de sujeto y objeto.<!-- .element: class="fragment" data-fragment-index="3" -->
                - Se usan para agrupar conjuntos de declaraciones.<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo de blank nodes

                ![Blank node](./img/example-blank-node.jpg)

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## grafos múltiples

                RDF permite agrupar declaraciones en varios grafos y asociarlos a un IRI determinado

                        <http://example.org/bob#me> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Person> <http://example.org/bob>

                **se denominan quads**


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                N-triples:

                        <http://example.org/bob#me> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Person> .
                        <http://example.org/bob#me> <http://xmlns.com/foaf/0.1/knows> <http://example.org/alice#me> .
                        <http://example.org/bob#me> <http://schema.org/birthDate> "1990-07-04"^^<http://www.w3.org/2001/XMLSchema#date> .
                        <http://example.org/bob#me> <http://xmlns.com/foaf/0.1/topic_interest> <http://www.wikidata.org/entity/Q12418> .

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                Turtle:

                        BASE   <http://example.org/>
                        PREFIX foaf: <http://xmlns.com/foaf/0.1/>
                        PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
                        PREFIX schema: <http://schema.org/>
                        PREFIX dcterms: <http://purl.org/dc/terms/>
                        PREFIX wd: <http://www.wikidata.org/entity/>

                        <bob#me>
                        a foaf:Person ;
                        foaf:knows <alice#me> ;
                        schema:birthDate "1990-07-04"^^xsd:date ;
                        foaf:topic_interest wd:Q12418 .

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                blank node:

                        PREFIX lio: <http://purl.org/net/lio#>

                        <http://dbpedia.org/resource/Mona_Lisa> lio:shows _:x .
                        _:x a <http://dbpedia.org/resource/Cypress> .

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                JSON-LD:

                        {
                            "@context": "example-context.json",
                            "@id": "http://example.org/bob#me",
                            "@type": "Person",
                            "birthdate": "1990-07-04",
                            "knows": "http://example.org/alice#me",
                            "interest": {
                              "@id": "http://www.wikidata.org/entity/Q12418",
                              "title": "Mona Lisa",
                              "subject_of": "http://data.europeana.eu/item/04802/243FA8618938F4117025F17A8B813C5F9AA4D619",
                              "creator": "http://dbpedia.org/resource/Leonardo_da_Vinci"
                      }
                    }

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                JSON-LD context:

                    {
                      "@context": {
                        "foaf": "http://xmlns.com/foaf/0.1/",
                        "Person": "foaf:Person",
                        "interest": "foaf:topic_interest",
                        "knows": {
                          "@id": "foaf:knows",
                          "@type": "@id"
                        },
                        "birthdate": {
                          "@id": "http://schema.org/birthDate",
                          "@type": "http://www.w3.org/2001/XMLSchema#date"
                        },
                        "dcterms": "http://purl.org/dc/terms/",
                        "title": "dcterms:title",
                        "creator": {
                          "@id": "dcterms:creator",
                          "@type": "@id"
                        },
                        "subject_of": {
                          "@reverse": "dcterms:subject",
                          "@type": "@id"
                        }
                      }
                    }

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización

                RDF/XML:

                    <?xml version="1.0" encoding="utf-8"?>
                    <rdf:RDF
                                     xmlns:dcterms="http://purl.org/dc/terms/"
                                     xmlns:foaf="http://xmlns.com/foaf/0.1/"
                                     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                                     xmlns:schema="http://schema.org/">
                       <rdf:Description rdf:about="http://example.org/bob#me">
                          <rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
                          <schema:birthDate rdf:datatype="http://www.w3.org/2001/XMLSchema#date">1990-07-04</schema:birthDate>
                          <foaf:knows rdf:resource="http://example.org/alice#me"/>
                          <foaf:topic_interest rdf:resource="http://www.wikidata.org/entity/Q12418"/>
                       </rdf:Description>
                       <rdf:Description rdf:about="http://www.wikidata.org/entity/Q12418">
                          <dcterms:title>Mona Lisa</dcterms:title>
                          <dcterms:creator rdf:resource="http://dbpedia.org/resource/Leonardo_da_Vinci"/>
                       </rdf:Description>
                       <rdf:Description rdf:about="http://data.europeana.eu/item/04802/243FA8618938F4117025F17A8B813C5F9AA4D619">
                          <dcterms:subject rdf:resource="http://www.wikidata.org/entity/Q12418"/>
                       </rdf:Description>
                    </rdf:RDF>

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## vocabularios

                - RDF se utiliza conjuntamente con vocabularios para proporcionar información semántica.<!-- .element: class="fragment" data-fragment-index="1" -->
                - Para definir vocabularios, RDF proporciona la herramienta básica RDF Schema (RDFs)<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## vocabularios

                - Clase: categoría para clasificar recursos.<!-- .element: class="fragment" data-fragment-index="1" -->
                - Tipo: relación entre instancia y su clase correspondiente.<!-- .element: class="fragment" data-fragment-index="2" -->
                - Dominio: colección de tipos que usan una propiedad.<!-- .element: class="fragment" data-fragment-index="3" -->
                - Rango: tipos de valores que puede tomar una propiedad.<!-- .element: class="fragment" data-fragment-index="4" -->

                **un recurso se considera miembro de una clase por sus propiedades**<!-- .element: class="fragment" data-fragment-index="5" -->


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## vocabularios
                <!-- .slide: style="font-size:30px" -->

                |Construct|Sintaxis|
                |---------|--------|
                |Class (class)|`C rdf:type rdfs:Class`|
                |Property (class)|`P rdf:type rdf:Property`|
                |type (property)|`I rdf:type C`|
                |subClassOf (property)|`C1 rdfs:subClassOf C2`|
                |subPropertyOf (property)|`P1 rdfs:subPropertyOf P2`|
                |domain (property)|`P rdfs:domain C`|
                |range (property)|`P rdfs:range C`|

                </script>
                </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ## vocabularios comunes
                            <!-- .slide: style="font-size:30px" -->

                            - <!-- .element: class="fragment" data-fragment-index="1" -->Dublin Core [DCT](http://dublincore.org/documents/dcmi-terms/)<!-- .element: class="fragment" data-fragment-index="1" -->
                            - <!-- .element: class="fragment" data-fragment-index="2" -->Friend of a Friend [FOAF](http://www.foaf-project.org/)<!-- .element: class="fragment" data-fragment-index="2" -->
                            - <!-- .element: class="fragment" data-fragment-index="3" -->[Schema.org](http://schema.org/)<!-- .element: class="fragment" data-fragment-index="3" -->
                            - <!-- .element: class="fragment" data-fragment-index="4" -->Data Catalog Vocabulary [DCAT](https://www.w3.org/TR/2014/REC-vocab-dcat-20140116/)<!-- .element: class="fragment" data-fragment-index="4" -->
                            - <!-- .element: class="fragment" data-fragment-index="5" -->RDF Data Cube vocabulary [QB](https://www.w3.org/TR/2014/REC-vocab-data-cube-20140116/)<!-- .element: class="fragment" data-fragment-index="5" -->
                            - <!-- .element: class="fragment" data-fragment-index="6" -->The Organization Ontology [ORG](https://www.w3.org/TR/2014/REC-vocab-org-20140116/)<!-- .element: class="fragment" data-fragment-index="6" -->

                            además de RDFs, OWL, SKOS...<!-- .element: class="fragment" data-fragment-index="7" -->

                        </script>
                    </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo informal
                    <Person> <type> <Class>
                    <is a friend of> <type> <Property>
                    <is a friend of> <domain> <Person>
                    <is a friend of> <range> <Person>
                    <is a good friend of> <subPropertyOf> <is a friend of>

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo real
                ![Modelo real](./img/icane_model.png)<!-- .element: height="75%" width="75%"-->

                </script>
                </section>

                </section>
<section>
<section data-id="1" data-markdown>
<script type="text/template">
# Introducción a Ontologías

</script>
</section>


                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Definición
                Para un filósofo:<!-- .element: class="fragment" data-fragment-index="1" -->

                ><!-- .element: class="fragment" data-fragment-index="2" -->Un sistema particular de categorías sistematizando cierta visión del mundo [Guarino, 1998]<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
<section data-id="1" data-markdown>
<script type="text/template">
## Definición
Para un científico de datos:<!-- .element: class="fragment" data-fragment-index="1" -->

><!-- .element: class="fragment" data-fragment-index="2" -->Una especificación formal de una conceptualización compartida [Struder et. al., 1998]<!-- .element: class="fragment" data-fragment-index="2" -->

</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes

Clases<!-- .element: class="fragment" data-fragment-index="1" -->

- Representan conceptos tomados en su sentido más amplio<!-- .element: class="fragment" data-fragment-index="2" -->
- Suelen estar organizadas en taxonomías<!-- .element: class="fragment" data-fragment-index="3" -->


</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes

Relaciones<!-- .element: class="fragment" data-fragment-index="1" -->

- Representan un tipo de asociación entre los conceptos del dominio<!-- .element: class="fragment" data-fragment-index="2" -->
- Las contenidas en una ontología normalmente son binarias (dominio - rango)<!-- .element: class="fragment" data-fragment-index="3" -->
- Se utilizan también para expresar atributos de conceptos (su rango es un tipo de datos y no un concepto)<!-- .element: class="fragment" data-fragment-index="4" -->


</script>
</section>
<section data-id="1" data-markdown>
<script type="text/template">
## Componentes

Axiomas<!-- .element: class="fragment" data-fragment-index="1" -->

- Modelan afirmaciones que son siempre ciertas<!-- .element: class="fragment" data-fragment-index="1" -->
- Sirven para verificar la consistencia de la ontología o de sus conocimientos almacenados<!-- .element: class="fragment" data-fragment-index="2" -->
- Son útiles para inferir conocimientos nuevos<!-- .element: class="fragment" data-fragment-index="3" -->


</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes

Instancias<!-- .element: class="fragment" data-fragment-index="1" -->

- Representan individuos o elementos en una ontología<!-- .element: class="fragment" data-fragment-index="2" -->

</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Beneficios

- Proporcionan definiciones comunes y compartidas sobre conceptos de un dominio<!-- .element: class="fragment" data-fragment-index="1" -->
- Permiten reutilizar conocimientos de un dominio<!-- .element: class="fragment" data-fragment-index="2" -->
- Proporcionan términos a utilizar al crear documentos RDF<!-- .element: class="fragment" data-fragment-index="3" -->
- Ofrecen un mecanismo de codificar conocimiento y semántica para ser procesados por máquinas<!-- .element: class="fragment" data-fragment-index="4" -->

</script>
</section>



                </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  RDFs

                RDF Schema

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Definición
                - Lenguaje de esquema básico y ligero<!-- .element: class="fragment" data-fragment-index="1" -->
                - En su naturaleza, es orientado a objetos<!-- .element: class="fragment" data-fragment-index="2" -->
                - Declarar tipos es sencillo (frente a las PKs y FKs de una BDR)<!-- .element: class="fragment" data-fragment-index="3" -->

                ><!-- .element: class="fragment" data-fragment-index="4" -->su propósito es definir vocabularios compartidos entre aplicaciones para facilitar el intercambio de datos entre ellas<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                `rdf:type`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" --> Permite especificar que un concepto es instancia de una clase<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:miHondaCivic rdf:type ex:Vehiculo
                        ex:miHondaCivic rdf:type ex:ArticuloEnVenta
                        ex:miHomdaCivic rdf:type ex:BienAsegurado
                <!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                `rdf:class`<!-- .element: class="fragment" data-fragment-index="1" -->

                `rdfs:property`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Relacionan clases y propiedades<!-- .element: class="fragment" data-fragment-index="2" -->

                      ex:articuloEnVenta rdf:type rdf:Class
                      ex:precio rdf:type rdfs:property
                <!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                `rdfs:domain`<!-- .element: class="fragment" data-fragment-index="1" -->

                `rdfs:range`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Dominio: conceptos a la que esa propiedad aplica<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->Rango: valores que la propiedad puede aceptar<!-- .element: class="fragment" data-fragment-index="3" -->

                        ex:precio rdfs:domain rdf:ArticuloEnVenta
                        ex:precio rdfs:range XSD:int
                <!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                `subClassOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Las instancias de una subclase lo son de su clase padre<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->Las propiedades de una clase lo son de su clase hija<!-- .element: class="fragment" data-fragment-index="3" -->

                        ex:cocheUsado rdfs:subClassOf rdf:ArticuloEnVenta
                <!-- .element: class="fragment" data-fragment-index="4" -->


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                `subPropertyOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Propiedades incluidas en otra propiedad más general<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneMadre rdfs:subPropertyOf rdf:tieneProgenitor
                <!-- .element: class="fragment" data-fragment-index="3" -->


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFs

                otros constructs<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->`rdfs:Label`:<!-- .element: class="fragment" data-fragment-index="2" --> texto descriptivo del recurso<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->`rdfs:Comment`: comentario más extenso sobre el recurso<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->`rdfs:SeeAlso`: enlaces a otras fuentes relevantes<!-- .element: class="fragment" data-fragment-index="4" -->
                - <!-- .element: class="fragment" data-fragment-index="5" -->`rdfs:Literal`: tipo de dato primitivo<!-- .element: class="fragment" data-fragment-index="5" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                       
                        <script type="text/template">
                                ### ejercicio
                                <!-- .slide: style="font-size:30px" -->
                                Expresar el siguiente conocimiento en RDF y RDFs. Utilizar un espacio de nombres 'ex' para la ontología creada. Usar N-Triples como formato de serialización.
                
                                - El Curry Tailandés es un plato tailandés basado en leche de coco.
                                - Pedro es alérgico a las nueces. 
                                - Pedro come Curry Tailandés.
                                - Todos los alérgicos a las nueces son compadecibles.
                                - Todo lo que tenga la propiedad "platoTailandésBasadoEn" es Tailandés.
                                - Todo lo que satisfaga la propiedad "platoTailandésBasadoEn" lleva nueces.
                                - La propiedad "platoTailandésBasadoEn" es un caso especial de la propiedad "tieneIngrediente".
                </script>
                </section>
                </section>
                <section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            #  OWL

                            Web Ontology Language



                        </script>
                    </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL

                - Uno de los estándares principales de la web semántica<!-- .element: class="fragment" data-fragment-index="1" -->
                - Permite un modelado rápido y flexible<!-- .element: class="fragment" data-fragment-index="2" -->
                - Base para un razonamiento automático eficiente<!-- .element: class="fragment" data-fragment-index="3" -->


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: características

                - Más expresivo que otros lenguajes de modelado<!-- .element: class="fragment" data-fragment-index="1" -->
                - Flexible: modelado incremental<!-- .element: class="fragment" data-fragment-index="2" -->
                - Eficiente: permite soportar varios tipos de tareas de razonamiento<!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFs
                vocabulario

                - OWL incluye RDFs y ofrece mucho más

                        ex:Madre           owl:unionOf        (ex:Progenitor, ex:Mujer)
                        IFCA:JohnSmith     owl:sameAs         PersonalDatabase:JohnQSmith
                        ex:MiPais          owl:allValuesFrom  (Pais:España, Pais:Italia, …)

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFs

                **flexibilidad**<!-- .element: class="fragment" data-fragment-index="1" -->

                - OWL permite especificar cómo usar un vocabulario y cómo no usarlo<!-- .element: class="fragment" data-fragment-index="2" -->
                - OWL permite restringir los modelos de datos para permitir consultas más rápidas<!-- .element: class="fragment" data-fragment-index="3" -->

                ><!-- .element: class="fragment" data-fragment-index="4" -->En RDFs un recurso puede definirse como clase e instancia simultáneamente. OWL no lo permite.<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFs
                **anotaciones**<!-- .element: class="fragment" data-fragment-index="1" -->

                **meta-metadatos**<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> OWL ofrece anotaciones para enlazar modelos de datos<!-- .element: class="fragment" data-fragment-index="2" -->

                        owl:Import
                        owl:versionInfo
                        owl:backwardsCompatibleWith
                        owl:deprecatedProperty
                <!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL

                - Existen para permitir un trade-off entre expresividad en el modelado y requisitos computacionales en el razonamiento automático<!-- .element: class="fragment" data-fragment-index="1" -->
                - Si no se está usando OWL para razonamiento automático, se puede usar el perfil más expresivo (<!-- .element: class="fragment" data-fragment-index="2" -->`OWL 2 / Full`<!-- .element: class="fragment" data-fragment-index="2" -->)<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / Full

                - El perfil más expresivo, permite usar todos los constructs disponibles<!-- .element: class="fragment" data-fragment-index="1" -->
                - Las reglas de inferencia pueden ser tan complejas que disparen el coste computacional (tiempo)<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / EL

                - Útil si se tienen muchas clases y propiedades enlazadas a través de relaciones complejas y se desea que el razonador descubra nuevas relaciones<!-- .element: class="fragment" data-fragment-index="1" -->
                - Dichas relaciones entre clases pueden inferirse en tiempo polinomial<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / QL

                - Orientado hacia un procesamiento eficiente de muchos datos de tipo instancia (por ejemplo, provenientes de una BDR)<!-- .element: class="fragment" data-fragment-index="1" -->
                - Está lo suficientemente limitado para poder reescribir una consulta en SQL<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / RL

                - Orientado hacia la ejecución eficiente en un motor de reglas de negocio<!-- .element: class="fragment" data-fragment-index="1" -->
                - Funciona mejor con datos en RDF y reglas que podrían implementar cualquier lógica de negocio arbitraria<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases
                - Una colección de individuos<!-- .element: class="fragment" data-fragment-index="1" -->
                - Una forma de describir parte del mundo<!-- .element: class="fragment" data-fragment-index="2" -->
                - Ej: persona, animal, dispositivo<!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                - Una colección de relaciones entre individuos<!-- .element: class="fragment" data-fragment-index="1" -->
                - Una forma de describir un tipo de relación entre individuos<!-- .element: class="fragment" data-fragment-index="2" -->
                - Ej: tienePadre, tieneAnimal, cumpleAños<!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: individuos
                - Objetos en el mundo<!-- .element: class="fragment" data-fragment-index="1" -->
                - Pertenecen a clases<!-- .element: class="fragment" data-fragment-index="2" -->
                - Se relacionan con otros objetos y con valores de datos a través de propiedades<!-- .element: class="fragment" data-fragment-index="3" -->
                - Ej: Miguel, AyuntamientoDeSantander, IFCA<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>


                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `intersectionOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> Cualquier instancia de la primera clase lo es también de las especificadas en la lista<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Madre     owl:intersectionOf    (ex:Mujer, ex:Progenitor)
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `unionOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> Cualquier instancia de la primera clase lo es también de <!-- .element: class="fragment" data-fragment-index="2" -->**al menos una** <!-- .element: class="fragment" data-fragment-index="2" -->especificadas en la lista<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Progenitor     owl:unionOf    (:Madre, :Padre)
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `complementOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> La primera clase es equivalente a todo lo que no esté en la segunda<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Progenitor     owl:complementOf    ex:NoProgenitor
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `disjointWith`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->La primera clase y la segunda no tienen miembros en común<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Hombre     owl:disjointWith    ex:Mujer
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `equivalentClass`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> La primera clase y la segunda contienen los mismos miembros<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:HumanoHembraAdulto     owl:equivalentClass    ex:Mujer
                <!-- .element: class="fragment" data-fragment-index="3" -->

                ¡No implica igualdad de clases! (no denotan los mismos conceptos)<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `sameAs`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" --> El primer recurso se refiere exactamente al mismo que el segundo<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Spiderman     owl:sameAs    ex:PeterParker
                <!-- .element: class="fragment" data-fragment-index="3" -->

                Enlaza a dos individuos <!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `differentFrom`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->El primer recurso se refiere a uno distinto del segundo<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:AnaPastorMinistra    owl:differentFrom    ex:AnaPastorPeriodista
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `DatatypeProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - La propiedad enlaza a valores de datos simples<!-- .element: class="fragment" data-fragment-index="2" -->

                `ex:cumpleAños`<!-- .element: class="fragment" data-fragment-index="3" -->

                enlaza a una fecha <!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `ObjectProperty` <!-- .element: class="fragment" data-fragment-index="1" -->

                - La propiedad enlaza a otro recurso <!-- .element: class="fragment" data-fragment-index="2" -->

                `ex:tieneConyuge`<!-- .element: class="fragment" data-fragment-index="3" -->

                enlaza a una persona (otro recurso)<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `TransitiveProperty` <!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Si la propiedad enlaza A con B y B con C, también enlaza A con C <!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneAncestro
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `SymmetricProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Si la propiedad relaciona A con B, también B con A<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneConyuge
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `AsymmetricProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Si la propiedad relaciona A con B, nunca relaciona B con A<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneHijo
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `ReflexiveProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->La propiedad enlaza algo consigo mismo<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:viveCon
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `IrreflexiveProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->La propiedad nunca enlaza algo consigo mismo<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneConyuge
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `FunctionalProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->La propiedad solo enlaza como mucho con un recurso<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:cumpleAños
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `InverseFunctionalProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->El sujeto de esta propiedad se identifica unívocamente por el valor de la misma<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:tieneDNI
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `InverseOf`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Las dos propiedades son inversas la una de la otra<!-- .element: class="fragment" data-fragment-index="2" -->

                       ex:tieneHijo    owl:InverseOf    ex:tieneProgenitor
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `equivalentProperty`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Las dos propiedades son exactamente las mismas, aunque tengan distinta intencionalidad<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:fechaNacimiento    owl:equivalentProperty   ex:cumpleAños
                <!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown style="font-size:30px;">
                <script type="text/template">
                ##  OWL: restricciones
                ><!-- .element: class="fragment" data-fragment-index="1" -->Una restricción es una clase que se define por una descripción de sus miembros en términos de propiedades existentes y clases.<!-- .element: class="fragment" data-fragment-index="1" -->
                `owl:onProperty`<!-- .element: class="fragment" data-fragment-index="1" --> especifica qué propiedad se va a usar en la definición de la clase restricción<!-- .element: class="fragment" data-fragment-index="1" -->

                Se usa la notación [...] para referirse a un nodo anónimo que será sujeto de todas las tripletas (una por línea, separadas por ;)<!-- .element: class="fragment" data-fragment-index="2" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones
                `cardinality, min-cardinality, max-cardinality`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->La propiedad puede tener un determinado número de valores<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Coche   owl:equivalentClass
                        [  rdf:type owl:Restriction;
                           owl:onProperty  ex:tieneRueda;
                           owl:cardinality "4"^^xsd:int].
                <!-- .element: class="fragment" data-fragment-index="3" -->

                *Todos aquellos individuos que tienen 4 ruedas*<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones
                `hasValue`<!-- .element: class="fragment" data-fragment-index="1" -->

                -<!-- .element: class="fragment" data-fragment-index="2" -->Todos los objetos de la propiedad tienen el valor especificado<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:HijosDePepe   owl:equivalentClass
                        [  rdf:type owl:Restriction;
                           owl:onProperty  ex:tienePadre;
                           owl:hasValue  ex:Pepe].
                <!-- .element: class="fragment" data-fragment-index="3" -->

                *Todos aquellos individuos que tienen de padre a Pepe*<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones
                `someValuesFrom`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Al menos un objeto de esa propiedad es miembro de la clase especificada<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Padre   owl:equivalentClass
                        [  rdf:type owl:Restriction;
                           owl:onProperty  ex:tieneHijo;
                           owl:someValuesFrom  ex:Person].
                <!-- .element: class="fragment" data-fragment-index="3" -->

                *Cualquier instancia de la clase Padre tiene al menos un hijo, que es instancia de la clase Persona*<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones
                `allValuesFrom`<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->Todos los objetos de esa propiedad son miembros de la clase especificada<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Vegetariano   owl:equivalentClass
                          [  rdf:type owl:Restriction;
                             owl:onProperty  ex:come;
                             owl:allValuesFrom  ex:NoCarne].
                <!-- .element: class="fragment" data-fragment-index="3" -->

                *La clase Vegetariano equivale a la clase de todos los individuos que comen "no carne".*<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>

                </section>

                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # SKOS
                Simple **Knowledge Organization Systems**

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción
                <!-- .slide: style="font-size:30px" -->

                ¿Qué es un KOS?<!-- .element: class="fragment" data-fragment-index="1" -->

                > <!-- .element: class="fragment" data-fragment-index="2" -->Un conjunto de elementos, controlados y estructurados, que pueden utilizarse para describir e indexar objetos, navegar por colecciones, etc. Se utilizan comúnmente en bibliotecas, museos y otras áreas.<!-- .element: class="fragment" data-fragment-index="2" -->

                SKOS nace para permitir crear organizaciones de conocimiento modulares que puedan ser reutilizadas y referenciadas en la Web.<!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción

                Tipos de KOS<!-- .element: class="fragment" data-fragment-index="1" -->
                - Taxonomía: la ciencia de la clasificación. Basada en relaciones jerárquicas.<!-- .element: class="fragment" data-fragment-index="2" -->
                - Tesauro: extensión de una taxonomía. Añade la capacidad de hacer otras declaraciones sobre los sujetos clasificados (ej: significado, definiciones).<!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción

                Utilidad<!-- .element: class="fragment" data-fragment-index="1" -->
                - Mayor robustez en las búsquedas (términos relacionados)<!-- .element: class="fragment" data-fragment-index="2" -->
                - Ayudan a construir mejores interfaces de navegación<!-- .element: class="fragment" data-fragment-index="3" -->
                - Permiten organizar formalmente el conocimiento de un dominio<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS vs ontologías
                - los KOS se usan para organizar conocimiento, las ontologías para representarlo.<!-- .element: class="fragment" data-fragment-index="1" -->
                - Los KOS son semánticamente mucho menos rigurosos que las ontologías.<!-- .element: class="fragment" data-fragment-index="2" -->

                ><!-- .element: class="fragment" data-fragment-index="3" -->Llevando los KOS a la Web Semántica se consigue hacer estos esquemas legibles por máquinas, promover la reutilización y potenciar la interoperabilidad<!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS
                vocabulario RDF para representar KOS (taxonomías, tesauros, esquemas de clasificación y listas de encabezados de materia).<!-- .element: class="fragment" data-fragment-index="1" -->

                        @prefix skos: <http://www.w3.org/2004/02/skos/core#> .
                <!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: conceptos
                `skos:Concept`<!-- .element: class="fragment" data-fragment-index="1" -->

                elemento fundamental del vocabulario SKOS.<!-- .element: class="fragment" data-fragment-index="1" -->

                ><!-- .element: class="fragment" data-fragment-index="2" -->Los conceptos son unidades de pensamiento, ideas o significados que subyacen en los sistemas de organización del conocimiento<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Animal   rdf:type    skos:Concept
                <!-- .element: class="fragment" data-fragment-index="3" -->

                **previamente deben representarse con URIs**<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas
                - Los conceptos se pueden caracterizar mediante etiquetas<!-- .element: class="fragment" data-fragment-index="1" -->
                - Todas son subpropiedades de <!-- .element: class="fragment" data-fragment-index="2" -->`rdfs:label`<!-- .element: class="fragment" data-fragment-index="2" -->
                - Se usan para asociar un concepto SKOS con un literal RDF en un idioma determinado<!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas
                `skos:prefLabel`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Permite asignar una etiqueta léxica preferida a un recurso.<!-- .element: class="fragment" data-fragment-index="2" -->
                - Debería contener términos usados como descriptores en sistemas de indexación<!-- .element: class="fragment" data-fragment-index="3" -->
                - Se recomienda asignar etiquetas preferidas únicas<!-- .element: class="fragment" data-fragment-index="4" -->
                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es.
                <!-- .element: class="fragment" data-fragment-index="5" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas
                `skos:altLabel`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Permite asignar una etiqueta léxica alternativa a un recurso.<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->Se utiliza para representar sinónimos, abreviaturas, acrónimos...<!-- .element: class="fragment" data-fragment-index="3" -->

                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es;
                          skos:altLabel     "criatura"@es.
                <!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas
                <!-- .slide: style="font-size:30px" -->
                `skos:hiddenLabel`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Permite asignar una etiqueta léxica oculta a un recurso.<!-- .element: class="fragment" data-fragment-index="2" -->
                - Se utiliza para alimentar motores de búsqueda o indexado de forma no visible.<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->Se suelen usar para incluir errores tipográficos frecuentes<!-- .element: class="fragment" data-fragment-index="4" -->

                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es;
                          skos:altLabel     "ganado"@es;
                          skos:hiddenLabel  "granado"@es;
                <!-- .element: class="fragment" data-fragment-index="5" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: otra caracterización
                `skos:definition`<!-- .element: class="fragment" data-fragment-index="1" -->

                usada para proporcionar una explicación completa del significado de un concepto<!-- .element: class="fragment" data-fragment-index="1" -->

                `skos:example, skos:scopeNote, skos:historyNote`<!-- .element: class="fragment" data-fragment-index="2" -->

                todas subpropiedades de <!-- .element: class="fragment" data-fragment-index="3" -->`skos:note`<!-- .element: class="fragment" data-fragment-index="3" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: relaciones semánticas
                ><!-- .element: class="fragment" data-fragment-index="1" -->El significado de un concepto no sólo se define por las palabras en lenguaje natural almacenadas en sus etiquetas, sino por sus relaciones con otros conceptos en el vocabulario<!-- .element: class="fragment" data-fragment-index="1" -->
                </script>
                </section>
                <section data-id="1" data-markdown style="font-size:30px;">
                <script type="text/template">
                ## SKOS: relaciones semánticas
                `skos:broader, skos:narrower`<!-- .element: class="fragment" data-fragment-index="1" -->

                usadas para representar estructura jerárquica en KOS<!-- .element: class="fragment" data-fragment-index="1" -->

                - <!-- .element: class="fragment" data-fragment-index="2" -->`skos:broader` <!-- .element: class="fragment" data-fragment-index="2" --><!-- .element: class="fragment" data-fragment-index="2" -->*se lee tiene un concepto más amplio*<!-- .element: class="fragment" data-fragment-index="2" -->
                - Una es la inversa de la otra<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->No son transitivas<!-- .element: class="fragment" data-fragment-index="4" -->

                        ex:mamíferos rdf:type skos:Concept;
                          skos:prefLabel "mamíferos"@es;
                          skos:broader ex:animales.
                <!-- .element: class="fragment" data-fragment-index="5" --> 

                 the subject of a skos:broader statement is the more specific concept involved in the assertion and its object is the more generic one. <!-- .element: class="fragment" data-fragment-index="6" --> 
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: relaciones semánticas
                `skos:related`<!-- .element: class="fragment" data-fragment-index="1" -->

                se utiliza para relaciones asociativas no jerárquicas entre dos conceptos.<!-- .element: class="fragment" data-fragment-index="1" -->

                - Es una relación simétrica<!-- .element: class="fragment" data-fragment-index="2" -->
                - No es transitiva<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->Es disjunta con <!-- .element: class="fragment" data-fragment-index="4" -->`skos:broader,skos:narrower`<!-- .element: class="fragment" data-fragment-index="4" -->

                        ex:pájaros rdf:type skos:Concept;
                          skos:prefLabel "pájaros"@es;
                          skos:related ex:ornitologia.
                <!-- .element: class="fragment" data-fragment-index="5" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: concept schemes
                `skos:ConceptScheme`<!-- .element: class="fragment" data-fragment-index="1" -->

                clase que agrupa vocabularios compilados con SKOS<!-- .element: class="fragment" data-fragment-index="1" -->

                        ex:tesauroAnimal rdf:type skos:ConceptScheme;
                          dct:title "Tesauro animal";
                          dct:creator ex:Pepe.
                <!-- .element: class="fragment" data-fragment-index="2" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: concept schemes
                `skos:hasTopConcept`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Propiedad que permite enlazar un concept scheme con el resto de conceptos que contiene.<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->Punto de acceso a la jerarquía de conocimiento.<!-- .element: class="fragment" data-fragment-index="3" -->

                        ex:tesauroAnimal rdf:type skos:ConceptScheme;
                          skos:hasTopConcept ex:mamíferos;
                          skos:hasTopConcept ex:peces.
                <!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: enlazado de conceptos
                `skos:closeMatch`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Implica que dos conceptos son lo suficientemente cercanos como para poder ser utilizados indistintamente.<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->No es transitiva<!-- .element: class="fragment" data-fragment-index="3" -->

                        dbpedia:Tennis rdf:type skos:ConceptScheme;
                          skos:prefLabel "tenis"@es;
                          skos:closeMatch ex2:Tenis.
                <!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: enlazado de conceptos
                `skos:exactMatch`<!-- .element: class="fragment" data-fragment-index="1" -->
                - Implica que dos conceptos tienen significados equivalentes<!-- .element: class="fragment" data-fragment-index="2" -->
                - Sí es transitiva<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->`closeMatch`<!-- .element: class="fragment" data-fragment-index="4" -->Es un enlace más fuerte que <!-- .element: class="fragment" data-fragment-index="4" -->`closeMatch`<!-- .element: class="fragment" data-fragment-index="4" -->

                        ex1:animal skos:exactMatch ex2:animals.
                <!-- .element: class="fragment" data-fragment-index="5" -->
                </script>
                </section>
                    
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: reutilización
                <!-- .slide: style="font-size:30px" -->
                `skos:inScheme`<!-- .element: class="fragment" data-fragment-index="1" -->
                - <!-- .element: class="fragment" data-fragment-index="2" -->Permite reutilizar conceptos de un esquema en otro.<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex1:referenceAnimalScheme rdf:type skos:ConceptScheme;
                          dct:title "Reference list of animals"@en.
                          ex1:cats rdf:type skos:Concept;
                          skos:prefLabel "cats"@en;
                          skos:inScheme ex1:referenceAnimalScheme.
                <!-- .element: class="fragment" data-fragment-index="3" -->

                - <!-- .element: class="fragment" data-fragment-index="4" -->La referencia a ex1:cats podría incluirse en otro esquema:<!-- .element: class="fragment" data-fragment-index="4" -->

                        ex2:catScheme rdf:type skos:ConceptScheme;
                        dct:title "The Complete Cat Thesaurus"@en.
                        ex1:cats skos:inScheme ex2:catScheme.
                <!-- .element: class="fragment" data-fragment-index="5" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: colecciones
                `skos:Collection`<!-- .element: class="fragment" data-fragment-index="1" -->
                - <!-- .element: class="fragment" data-fragment-index="2" -->Permite agrupar conceptos en una colección<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:Francia rdf:type skos:Concept.
                        ex:España rdf:type skos:Concept.
                        ex:Italia rdf:type skos:Concept.
                        ex:PaisesEuropeos rdf:type skos:Collection;
                          skos:member ex:Francia;
                          skos:member ex:España;
                          skos:member ex:Italia.
                <!-- .element: class="fragment" data-fragment-index="3" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: colecciones
                `skos:OrderedCollection`<!-- .element: class="fragment" data-fragment-index="1" -->
                - <!-- .element: class="fragment" data-fragment-index="2" -->Capturan orden entre los elementos<!-- .element: class="fragment" data-fragment-index="2" -->

                        ex:niños rdf:type skos:Concept.
                        ex:adolescentes rdf:type skos:Concept.
                        ex:adultos rdf:type skos:Concept.

                        _:b0 rdf:type skos:OrderedCollection;
                           skos:prefLabel "personas por grupo de edad"@en;
                           skos:memberList _:b1.
                        _:b1 rdf:first ex:niños;
                           rdf:rest _:b2.
                        _:b2 rdf:first ex:adolescentes;
                           rdf:rest _:b3.
                        _:b3 rdf:first ex:adultos;
                           rdf:rest rdf:nil.
                <!-- .element: class="fragment" data-fragment-index="3" -->


                </script>
                </section>

                </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # modelado de ontologías
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  clases básicas
                <!-- .slide: style="font-size:30px" -->
                - <!-- .element: class="fragment" data-fragment-index="1" -->`owl:Thing`<!-- .element: class="fragment" data-fragment-index="1" -->: todas las clases heredan de esta y todas las instancias lo son de ella.<!-- .element: class="fragment" data-fragment-index="1" -->
                - <!-- .element: class="fragment" data-fragment-index="2" -->`owl:Class`<!-- .element: class="fragment" data-fragment-index="2" -->: clase de todos los recursos que son clases.<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->`owl:DatatypeProperty`<!-- .element: class="fragment" data-fragment-index="3" -->: clase de todas las propiedades cuyos rangos son literales.<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->`owl:ObjectProperty`<!-- .element: class="fragment" data-fragment-index="4" -->: clase de todas las propiedades cuyos rangos son instancias de `owl:Class`.<!-- .element: class="fragment" data-fragment-index="4" -->
                - <!-- .element: class="fragment" data-fragment-index="5" -->`rdf:XMLLiteral`<!-- .element: class="fragment" data-fragment-index="5" -->: clase de todos los valores literales XML definidos en la especificación XML Schema.<!-- .element: class="fragment" data-fragment-index="5" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  propiedades básicas
                <!-- .slide: style="font-size:30px" -->
                - <!-- .element: class="fragment" data-fragment-index="1" -->`rdf:type`<!-- .element: class="fragment" data-fragment-index="1" -->: tipo de un recurso. Especifica que es una instancia de una clase.<!-- .element: class="fragment" data-fragment-index="1" -->
                - <!-- .element: class="fragment" data-fragment-index="2" -->`rdfs:subClassOf`<!-- .element: class="fragment" data-fragment-index="2" -->: especifica que una clase es subclase de otra.<!-- .element: class="fragment" data-fragment-index="2" -->
                - <!-- .element: class="fragment" data-fragment-index="3" -->`rdfs:domain`<!-- .element: class="fragment" data-fragment-index="3" -->: implica que, cuando una propiedad se utilice en una tripleta, el sujeto de dicha tripleta tendrá que ser instancia de la clase especificada por<!-- .element: class="fragment" data-fragment-index="3" --> `rdfs:domain`<!-- .element: class="fragment" data-fragment-index="3" -->
                - <!-- .element: class="fragment" data-fragment-index="4" -->`rdfs:range`<!-- .element: class="fragment" data-fragment-index="4" -->: implica que, cuando la propiedad se utilice en una tripleta, el objeto de dicha tripleta tendrá que ser instancia de la clase especificada por<!-- .element: class="fragment" data-fragment-index="4" --> `rdfs:range`<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                construir la ontología<!-- .element: class="fragment" data-fragment-index="1" -->

                - Crear la ontología<!-- .element: class="fragment" data-fragment-index="2" -->
                - Nombrar las clases y caracterizarlas<!-- .element: class="fragment" data-fragment-index="3" -->
                - Nombrar las propiedades y caracterizarlas<!-- .element: class="fragment" data-fragment-index="4" -->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                declarar hechos sobre un dominio<!-- .element: class="fragment" data-fragment-index="1" -->

                - Proporcionar información sobre individuos<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                razonar sobre hechos y ontologías<!-- .element: class="fragment" data-fragment-index="1" -->

                - Determinar las consecuencias de lo construido y afirmado<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                herramientas: <!-- .element: class="fragment" data-fragment-index="1" -->[Protégé](https://protege.stanford.edu/)<!-- .element: class="fragment" data-fragment-index="1" -->
                - Editor de ontologías de código abierto<!-- .element: class="fragment" data-fragment-index="2" -->
                - Marco de trabajo para construir sistemas inteligentes<!-- .element: class="fragment" data-fragment-index="3" -->
                - Modular y extensible a través de plugins<!-- .element: class="fragment" data-fragment-index="4" -->


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  ejemplo: inferencia con Protégé

                - Celestino padre-de José Luis<!-- .element: class="fragment" data-fragment-index="1" -->
                - José Luis padre-de Miguel<!-- .element: class="fragment" data-fragment-index="2" -->
                - tiene-padre inversa de padre-de<!-- .element: class="fragment" data-fragment-index="3" -->

                ¿qué infiere el razonador?<!-- .element: class="fragment" data-fragment-index="4" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  ejemplo: modelado SKOS

                - importar vocabulario <!-- .element: class="fragment" data-fragment-index="1" -->[SKOS](http://purl.org/iso25964/skos-thes)<!-- .element: class="fragment" data-fragment-index="1" -->
                - Definir categoría, sección, subsección, dataset, serie<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  ejemplo: vocabularios, skos

                            - Acceder a <!-- .element: class="fragment" data-fragment-index="1" -->[punto SPARQL](http://www.icane.es/semantic-web)<!-- .element: class="fragment" data-fragment-index="1" -->
                            - Lanzar consulta:<!-- .element: class="fragment" data-fragment-index="2" -->
                                    construct {?s ?p ?o} where {?s a skos:Concept; ?p ?o}
                            - Acceder a <!-- .element: class="fragment" data-fragment-index="3" -->[vocabulario](http://www.icane.es/opendata/vocab)<!-- .element: class="fragment" data-fragment-index="3" --> e importar en Protégé<!-- .element: class="fragment" data-fragment-index="3" -->
                            - Parsear RDFa en visualizador<!-- .element: class="fragment" data-fragment-index="4" -->

                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  notación Manchester
                            ![Notación Manchester](./img/manchester.png)<!-- .element height="75%" width="75%" -->


                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  ejercicio: pizzas
                            - [toppings](https://gist.github.com/predicador37/23a8ebead3e3cded708d89e0ee1ef5fe)


                        </script>
                    </section>

                </section>
                <section data-id="1" data-markdown>
                        <script type="text/template">
                        ##  links

                           - [RDF primer](https://www.w3.org/TR/rdf11-primer/)
                           - [OWL 2 primer](https://www.w3.org/TR/owl2-primer/)
                           - [SKOS primer](https://www.w3.org/TR/skos-primer/)
                           - [Cambridge Semantics RDF](https://www.cambridgesemantics.com/blog/semantic-university/learn-rdf/)
                           - [Cambridge Semantics OWL](https://www.cambridgesemantics.com/blog/semantic-university/learn-owl-rdfs/)
                           - [Cambridge Semantics SPARQL](https://www.cambridgesemantics.com/blog/semantic-university/learn-sparql/)

                        </script>
                </section>

                <section>

                <div>
                <a href="https://masterdatascience.ifca.es/"><img alt="Logotipo Máster Data Science IFCA"  src="./img/logo_3.png" style="max-width: none; max-height: none; color: rgb(255, 153, 0);  vertical-align:middle;" /></a>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;"><a href="https://github.com/masterdatascience-uimp-uc/ontologies">Acceso al repositorio con la presentación</a></span></p>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;">URL de la presentación: <a href="https://masterdatascience-uimp-uc.github.io/ontologies/">https://masterdatascience-uimp-uc.github.io/ontologies/</a></span></p>


                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;"><a href="https://twitter.com/predicador37">Miguel Expósito Martín</a></span></p>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;"><a href="mailto:miguel.exposito@gmail.com">miguel.exposito@gmail.com</a></span></p>

                </div>

                </section>

				</div>

			</div>

			<script src="lib/js/head.min.js"></script>
			<script src="js/reveal.js"></script>

			<script>

				// Full list of configuration options available at:
				// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/tagcloud/tagcloud.js', async: true },
			{ src: 'plugin/chalkboard/chalkboard.js' },
			{ src: 'plugin/notes/notes.js', async: true }
			],
			keyboard: {
				67: function() { RevealChalkboard.toggleNotesCanvas() },	// toggle notes canvas when 'c' is pressed
				66: function() { RevealChalkboard.toggleChalkboard() },	// toggle chalkboard when 'b' is pressed
				46: function() { RevealChalkboard.clear() },	// clear chalkboard when 'DEL' is pressed
				 8: function() { RevealChalkboard.reset() },	// reset chalkboard data on current slide when 'BACKSPACE' is pressed
				68: function() { RevealChalkboard.download() },	// downlad recorded chalkboard drawing when 'd' is pressed
			}
			});

			</script>

		</body>
	</html>
