<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Ontologías</title>

		<meta name="description" content="Ontologías">
		<meta name="author" content="Alejandro Villar Fernádez">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/solarized.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                <section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            # semántica
                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                           - Redes semánticas
                           - Minería de textos y minería web
                           - **Ontologías**
                           - Linked Data
                           - Análisis de redes complejas
                        </script>
                    </section>

                </section>
                <section>
				<section data-id="1" data-markdown>
					<script type="text/template">
					# Ontologías

					</script>
				</section>
                <section data-id="1" data-markdown>
                    <script type="text/template">
                        ### Ontologías
                        - Introducción a la Web Semántica
                        - Introducción a RDF
                        - Introducción a Ontologías
                        - RDFS
                        - OWL
                        - SKOS


                    </script>
                </section>
                </section>
                <section>
                        <section data-id="1" data-markdown>
                                <script type="text/template">
                                                        ## La Web Semántica
                                                                                
                                                        ![Portada de Scientific American 2001](./img/semantic_web.png)<!-- .element height="40%" width="40%" -->
                                                                      
                                                        </script>
                        </section>
                        <section data-id="1" data-markdown>
                                <script type="text/template">
                                        ### y linked open data
                                        [![Parte de la nube de LOD](./img/lod-datasets_2009-07-14_cropped.png)](https://lod-cloud.net/)

                                </script>
                        </section>
               
                <section data-id="1" data-markdown>
                        <script type="text/template">
                                ### ¿en qué se basan?

                                RDF + XML + ontologías 

                                **sujeto - predicado - objeto** 

                                    <http://example.org/bob#me>
                                    <http://www.w3.org/1999/02/22-rdf-syntax-ns#type>
                                    <http://xmlns.com/foaf/0.1/Person> .
                                

                                ¡y SPARQL! 
                        </script>
                </section>
                <section data-id="1" data-markdown>
                        <script type="text/template">
                                ### ¿cómo es una aplicación semántica?
                                ![Arquitectura aplicación semántica](./img/despliegue.png)
                        </script>
                </section>
        </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # Introducción a RDF

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Qué es RDF?

                > Un marco de trabajo para expresar información sobre **recursos**.

                documentos, personas, objetos físicos y/o abstractos...<!-- .element: class="fragment" data-fragment-index="1" -->

                - información en la web necesita ser procesada por aplicaciones<!-- .element: class="fragment" data-fragment-index="2" -->
                - RDF ofrece un marco común sin pérdida de significado<!-- .element: class="fragment" data-fragment-index="2" -->

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                 ## ¿Para qué RDF?
                 - para añadir información legible para motores de búsqueda
                 - para enriquecer un dataset [enlazándolo](http://lod-cloud.net/) con datasets de terceros
                 - para entrelazar feeds de APIs, facilitando su descubrimiento
                 - para construir agregaciones de datos sobre determinados temas

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Para qué RDF? (II)
                - para proporcionar un estándar de intercambio de datos entre BBDDs
                - para permitir consultas cruzadas a datasets de una organización
                - para enriquecer, describir y contextualizar los datos
                - para fomentar nuevas asociaciones entre datasets


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Y el modelo relacional?
                - una tabla es fácil de mostrar, ordenar y editar
                - su semántica está en las filas y columnas de sus tablas
                - una BDR permite cruzar varias tablas de forma estándar
                - evolucionar los esquemas es complejo:

                datos + consultas



                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ¿Y el modelo relacional? (II)
                - además, los esquemas se pueden volver tremendamente complicados

                soluciones: procedimientos almacenados y ORMs

                #### a veces, es necesario modelar para lo inesperado: flexibilidad

                </script>
                </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### un esquema complicado
                            ![Esquema complejo](./img/data_model_hell.png)
                        </script>
                    </section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### comparativa de paradigmas
                            |Mundo Relacional|Mundo Semántico|
                            |----------------|----------------|
                            |Registro de tabla|Nodo RDF|
                            |Columna de tabla|RDF property Type|
                            |Celda de tabla|Valor|
                            |Consulta SQL|Consulta SPARQL|
                            |Modelo de datos|Ontología|
                        </script>
                    </section>

                    <section data-id="1" data-markdown style="font-size:35px">
                        <script type="text/template">
                            ### almacenes RDF vs BDR
                            - **Flexibilidad:** su esquema flexible permite realizar cambios sin paradas ni rediseños, cosa que no ocurre con una base de datos relacional.
                            - **Estandarización:** el nivel de estandarización de RDF y SPARQL es mucho mayor que el de SQL. Es prácticamente inmediato sustituir un almacén de tripletas por otro, mientras que en el caso de las bases de datos relacionales es necesario tener en cuenta los distintos dialectos e implementaciones de SQL según el fabricante.
                            - **Expresividad:** es mucho más sencillo modelar datos complejos y con elevado número de relaciones entre ellos en RDF que en SQL. Ocurre al contrario si los datos son de naturaleza tabular, naturalmente.
                        </script>
                    </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ### almacenes RDF vs BDR (II)
                            no todo son ventajas...
                            - **Madurez:** las bases de datos relacionales son mucho más maduras y presentan más funcionalidades que los almacenes de ternas.
                            - **Coste de almacenamiento**: El coste por unidad de información almacenada en un almacén de ternas es mucho mayor que el de una base de datos relacional, lo cual puede ser crítico si se están tratando grandes volúmenes de datos.
                        </script>
                    </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo de datos RDF

                - RDF permite hacer declaraciones sobre recursos.
                - El formato de una declaración es sencillo:

                **sujeto + predicado + objeto**

                - El predicado representa la naturaleza de la relación
                - Las declaraciones RDF se denominan tripletas


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo informal de tripletas

                        <Bob> <is a> <person>.
                        <Bob> <is a friend of> <Alice>.
                        <Bob> <is born on> <the 4th of July 1990>.
                        <Bob> <is interested in> <the Mona Lisa>.
                        <the Mona Lisa> <was created by> <Leonardo da Vinci>.
                        <the video 'La Joconde à Washington'> <is about> <the Mona Lisa>.

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo informal de tripletas

                ![Grafo de tripletas](./img/example-graph.jpg)<!-- .element: height="75%" width="75%"-->
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## URI, URI, URL
                - URI: identifica un recurso físico o abstracto<!-- .element: class="fragment" data-fragment-index="1" -->
                - IRI: como la URI, pero incorpora UTF-8<!-- .element: class="fragment" data-fragment-index="2" -->
                - URL: una URI que, además de identificar, proporciona una forma de localizar el recurso a través de su mecanismo de acceso primario<!-- .element: class="fragment" data-fragment-index="3" -->

                http://dbpedia.org/resource/Leonardo_da_Vinci<!-- .element: class="fragment" data-fragment-index="3" -->

                **son identificadores únicos (fuertes)**<!-- .element: class="fragment" data-fragment-index="4" -->


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## URI, IRI, URL (II)
                Es común acortar los URIs asignando un espacio de nombres a su base:

                http://www.w3.org/1999/02/22-rdf-syntax-ns#type

                rdf = http://www.w3.org/1999/02/22-rdf-syntax-ns#

                **rdf:type**


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## literales
                valores básicos que no son IRIs (strings, números, fechas...)

                Muchos [tipos de datos](https://www.w3.org/TR/2014/REC-rdf11-concepts-20140225/#section-Datatypes) provienen de XML Schema


                </script>
                </section>
                
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## literales (II)
                
                ![](./img/xsd-type-hierarchy.gif)<!-- .element width="45%" -->
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## blank nodes

                - A veces es útil representar un recurso sin usar un identificador.
                - Se asemejan a variables en álgebra: representan algo cuyo valor se desconoce.
                - Suelen aparecer en las posiciones de sujeto y objeto.
                - Se usan para agrupar conjuntos de declaraciones.

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## ejemplo de blank nodes

                ![Blank node](./img/example-blank-node.jpg)

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## grafos múltiples

                RDF permite agrupar declaraciones en varios grafos y asociarlos a un IRI determinado

                        <http://example.org/bob#me> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Person> <http://example.org/bob>

                **se denominan quads**


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (I)

                N-triples:

                        <http://example.org/bob#me> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://xmlns.com/foaf/0.1/Person> .
                        <http://example.org/bob#me> <http://xmlns.com/foaf/0.1/knows> <http://example.org/alice#me> .
                        <http://example.org/bob#me> <http://schema.org/birthDate> "1990-07-04"^^<http://www.w3.org/2001/XMLSchema#date> .
                        <http://example.org/bob#me> <http://xmlns.com/foaf/0.1/topic_interest> <http://www.wikidata.org/entity/Q12418> .

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (II)

                Turtle:
                
                    @base <http://example.org/> .
                    @prefix owl: <http://www.w3.org/2002/07/owl#> .
                    @prefix foaf: <http://xmlns.com/foaf/0.1/> .
                    @prefix rel: <http://www.perceive.net/schemas/relationship/> .

                    <#green-goblin>
                        rel:enemyOf <#spiderman> ;
                        a foaf:Person ;    # in the context of the Marvel universe
                        foaf:name "Green Goblin" .

                    <#spiderman>
                        rel:enemyOf <#green-goblin> ;
                        a foaf:Person ;
                        foaf:knows [
                            a foaf:Person;
                            foaf:name "Mary Jane Watson" .
                        ] ;
                        foaf:name "Spiderman", "Человек-паук"@ru .
                    
                    _:pp owl:sameAs <#spiderman> .

                </script>
                </section>
                
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (III)

                Turtle:
                  - Prefijos:
                  
                        PREFIX pref: <http://mi.prefjo.com#>
                  - URI: 
                        <http://www.google.es>
                        pref:Clase
                  - Blank nodes: 
                        _:blid
                        [ foaf:name "Anon" ]

                </script>
                </section>
                
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (IV)

                Turtle:
                  - Tripletas
                    - Finalización: `.`
                    - Repetir sujeto + predicado: `,`
                    - Repetir sujeto: `;`
                  - `a` es alias de `rdf:type`
                  - Comentarios
                        # Comentario

                </script>
                </section>
                
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (V)

                Turtle:
                  - Literales
                  
                  
                    "Una cadena de caracteres"
                    3
                    "3"^^xsd:int
                    "2019-05-22"^^xsd:date
                    "A character string"@en

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (VI)

                blank node:

                        PREFIX lio: <http://purl.org/net/lio#>

                        <http://dbpedia.org/resource/Mona_Lisa> lio:shows _:x .
                        _:x a <http://dbpedia.org/resource/Cypress> .

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (VII)

                JSON-LD:

                    {
                        "@context": "example-context.json",
                        "@id": "http://example.org/bob#me",
                        "@type": "Person",
                        "birthdate": "1990-07-04",
                        "knows": "http://example.org/alice#me",
                        "interest": {
                            "@id": "http://www.wikidata.org/entity/Q12418",
                            "title": "Mona Lisa",
                            "subject_of": "http://data.europeana.eu/item/04802/243FA8618938F4117025F17A8B813C5F9AA4D619",
                            "creator": "http://dbpedia.org/resource/Leonardo_da_Vinci"
                        } 
                    }

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (VIII)

                JSON-LD context:

                    {
                      "@context": {
                        "foaf": "http://xmlns.com/foaf/0.1/",
                        "Person": "foaf:Person",
                        "interest": "foaf:topic_interest",
                        "knows": {
                          "@id": "foaf:knows",
                          "@type": "@id"
                        },
                        "birthdate": {
                          "@id": "http://schema.org/birthDate",
                          "@type": "http://www.w3.org/2001/XMLSchema#date"
                        },
                        "dcterms": "http://purl.org/dc/terms/",
                        "title": "dcterms:title",
                        "creator": {
                          "@id": "dcterms:creator",
                          "@type": "@id"
                        },
                        "subject_of": {
                          "@reverse": "dcterms:subject",
                          "@type": "@id"
                        }
                      }
                    }

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## formatos de serialización (IX)

                RDF/XML:

                    <?xml version="1.0" encoding="utf-8"?>
                    <rdf:RDF
                                     xmlns:dcterms="http://purl.org/dc/terms/"
                                     xmlns:foaf="http://xmlns.com/foaf/0.1/"
                                     xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
                                     xmlns:schema="http://schema.org/">
                       <rdf:Description rdf:about="http://example.org/bob#me">
                          <rdf:type rdf:resource="http://xmlns.com/foaf/0.1/Person"/>
                          <schema:birthDate rdf:datatype="http://www.w3.org/2001/XMLSchema#date">1990-07-04</schema:birthDate>
                          <foaf:knows rdf:resource="http://example.org/alice#me"/>
                          <foaf:topic_interest rdf:resource="http://www.wikidata.org/entity/Q12418"/>
                       </rdf:Description>
                       <rdf:Description rdf:about="http://www.wikidata.org/entity/Q12418">
                          <dcterms:title>Mona Lisa</dcterms:title>
                          <dcterms:creator rdf:resource="http://dbpedia.org/resource/Leonardo_da_Vinci"/>
                       </rdf:Description>
                       <rdf:Description rdf:about="http://data.europeana.eu/item/04802/243FA8618938F4117025F17A8B813C5F9AA4D619">
                          <dcterms:subject rdf:resource="http://www.wikidata.org/entity/Q12418"/>
                       </rdf:Description>
                    </rdf:RDF>

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Vocabularios

                - RDF se utiliza conjuntamente con vocabularios para proporcionar información semántica.
                - Para definir vocabularios, RDF proporciona la herramienta básica RDF Schema (RDFS).

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Vocabularios (II)

                - Clase: categoría para clasificar recursos.
                - Tipo: relación entre instancia y su clase correspondiente.
                - Dominio: colección de tipos que usan una propiedad.
                - Rango: tipos de valores que puede tomar una propiedad.

                **un recurso se considera miembro de una clase por el rango/dominio de sus propiedades**

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## vocabularios (III)
                <!-- .slide: style="font-size:30px" -->

                |Construct|Sintaxis|
                |---------|--------|
                |Class (class)|`C rdf:type rdfs:Class`|
                |Property (class)|`P rdf:type rdf:Property`|
                |type (property)|`I rdf:type C`|
                |subClassOf (property)|`C1 rdfs:subClassOf C2`|
                |subPropertyOf (property)|`P1 rdfs:subPropertyOf P2`|
                |domain (property)|`P rdfs:domain C`|
                |range (property)|`P rdfs:range C`|

                </script>
                </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ## vocabularios comunes
                            <!-- .slide: style="font-size:30px" -->

                            - Dublin Core [DC](http://purl.org/dc/elements/1.1/) / Dublin Core terms [DCT](http://purl.org/dc/terms/)
                            - Friend of a Friend [FOAF](http://www.foaf-project.org/)
                            - [Schema.org](http://schema.org/)
                            - Data Catalog Vocabulary [DCAT](https://www.w3.org/TR/2014/REC-vocab-dcat-20140116/)
                            - RDF Data Cube vocabulary [QB](https://www.w3.org/TR/2014/REC-vocab-data-cube-20140116/)
                            - The Organization Ontology [ORG](https://www.w3.org/TR/2014/REC-vocab-org-20140116/)

                            además de RDFS, OWL, SKOS...

                        </script>
                    </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo informal
                    <Person> <type> <Class>
                    <is a friend of> <type> <Property>
                    <is a friend of> <domain> <Person>
                    <is a friend of> <range> <Person>
                    <is a good friend of> <subPropertyOf> <is a friend of>

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelo real
                ![Modelo real](./img/icane_model.png)<!-- .element: height="75%" width="75%"-->

                </script>
                </section>

                </section>
<section>
<section data-id="1" data-markdown>
<script type="text/template">
# Introducción a Ontologías

</script>
</section>


                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Definición (I)
                Para un filósofo:

                >Un sistema particular de categorías sistematizando cierta visión del mundo [Guarino, 1998]

                </script>
                </section>
<section data-id="1" data-markdown>
<script type="text/template">
## Definición (II)
Para un científico de datos:

>Una especificación formal de una conceptualización compartida [Struder et. al., 1998]

</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes

Clases

- Representan conceptos tomados en su sentido más amplio
- Suelen estar organizadas en taxonomías


</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes (II)

Relaciones

- Representan un tipo de asociación entre los conceptos del dominio
- Las contenidas en una ontología normalmente son binarias (dominio - rango)
- Se utilizan también para expresar atributos de conceptos (su rango es un tipo de datos y no un concepto)


</script>
</section>
<section data-id="1" data-markdown>
<script type="text/template">
## Componentes (III)

Axiomas

- Modelan afirmaciones que son siempre ciertas
- Sirven para verificar la consistencia de la ontología o de sus conocimientos almacenados
- Son útiles para inferir conocimientos nuevos


</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Componentes (IV)

Instancias

- Representan individuos o elementos en una ontología

</script>
</section>

<section data-id="1" data-markdown>
<script type="text/template">
## Beneficios

- Proporcionan definiciones comunes y compartidas sobre conceptos de un dominio
- Permiten reutilizar conocimientos de un dominio
- Proporcionan términos a utilizar al crear documentos RDF
- Ofrecen un mecanismo de codificar conocimiento y semántica para ser procesados por máquinas

</script>
</section>



                </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  RDFS

                RDF Schema

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## Definición
                - Lenguaje de esquema básico y ligero
                - En su naturaleza, es orientado a objetos
                - Declarar tipos es sencillo (frente a las PKs y FKs de una BDR)

                >su propósito es definir vocabularios compartidos entre aplicaciones para facilitar el intercambio de datos entre ellas
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS

                `rdf:type`

                -  Permite especificar que un concepto es instancia de una clase

                        ex:miHondaCivic rdf:type ex:Vehiculo .
                        ex:miHondaCivic rdf:type ex:ArticuloEnVenta .
                        ex:miHomdaCivic rdf:type ex:BienAsegurado .
                
                - En Turtle/SPARQL se puede abreviar con `a`:
                
                        ex:miHondaCivic a ex:Vehiculo .

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS (II)

                - `rdfs:Resource`: Clase de *todo* (En RDF, todo son recursos)
                    - `rdfs:Class`: Clase RDF
                    - `rdfs:Literal`: Clase de los literales
                    - `rdf:Property`: Clase de las propiedades
                
                
                      ex:ArticuloEnVenta rdf:type rdfs:Class .
                      ex:precio rdf:type rdf:Property .

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS (III)

                - `rdfs:domain`: Dominio (conceptos a la que esa propiedad aplica)

                - `rdfs:range`: Rango (valores que la propiedad puede aceptar)

                        ex:precio rdfs:domain rdf:ArticuloEnVenta .
                        ex:precio rdfs:range xsd:integer .
                        
                ### ¡Inferencia!
                

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS (IV)

                `subClassOf`

                - Las instancias de una subclase lo son de su clase padre
                - Las propiedades de una clase lo son de su clase hija (**herencia**)

                        ex:Coche rdfs:subClassOf ex:Vehiculo .
                


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS (V)

                `subPropertyOf`

                - Propiedades incluidas en otra propiedad más general

                        ex:tieneMadre rdfs:subPropertyOf rdf:tieneProgenitor
                


                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## modelado con RDFS (VI)

                - `rdfs:label`: texto descriptivo del recurso
                - `rdfs:comment`: comentario más extenso sobre el recurso
                - `rdfs:seeAlso`: enlaces a otras fuentes relevantes
                - `rdfs:isDefinedBy`: relación del recurso con documento u ontología que lo define

                </script>
                </section>
                <section data-id="1" data-markdown>
                       
                        <script type="text/template">
                                ### ejercicio
                                <!-- .slide: style="font-size:30px" -->
                                Expresar el siguiente conocimiento en RDF y RDFS. Utilizar un espacio de nombres 'ex' para la ontología creada, y Turtle como formato de serialización. 
                
                                - El Curry Tailandés es un plato tailandés basado en leche de coco.
                                - Pedro es alérgico a las nueces. 
                                - Pedro come Curry Tailandés.
                                - Todos los alérgicos a las nueces son compadecibles.
                                - Todo lo que tenga la propiedad "platoTailandésBasadoEn" es comestible.
                                - Todo lo que satisfaga la propiedad "platoTailandésBasadoEn" es un ingrediente de cocina.
                                - La propiedad "platoTailandésBasadoEn" es un caso especial de la propiedad "tieneIngrediente".
                </script>
                </section>
                </section>
                <section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            #  OWL

                            Web Ontology Language



                        </script>
                    </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL

                - Uno de los estándares principales de la web semántica
                - Permite un modelado rápido y flexible
                - Base para un razonamiento automático eficiente


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: características

                - Más expresivo que otros lenguajes de modelado
                - Flexible: modelado incremental
                - Eficiente: permite soportar varios tipos de tareas de razonamiento

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFS
                vocabulario

                - OWL 2 Full incluye RDFS y ofrece mucho más

                        ex:Madre           owl:unionOf        (ex:Progenitor, ex:Mujer)
                        IFCA:JohnSmith     owl:sameAs         PersonalDatabase:JohnQSmith
                        ex:MiPais          owl:allValuesFrom  (Pais:España, Pais:Italia, …)

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFS (II)

                **flexibilidad**

                - OWL permite especificar cómo usar un vocabulario y cómo no usarlo
                - OWL permite restringir los modelos de datos para permitir consultas más rápidas

                >En RDFS un recurso puede definirse como clase e instancia simultáneamente. OWL 2 DL no lo permite.

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: diferencias con RDFS (III)
                **anotaciones**

                **meta-metadatos**

                - OWL ofrece anotaciones para enlazar modelos de datos

                        owl:Import
                        owl:versionInfo
                        owl:backwardsCompatibleWith
                        owl:deprecatedProperty
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL

                - Existen para permitir un trade-off entre expresividad en el modelado y requisitos computacionales en el razonamiento automático
                - Si no se está usando OWL para razonamiento automático, se puede usar el perfil más expresivo (OWL 2 / Full)

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / Full

                - El perfil más expresivo, permite usar todos los constructs disponibles
                - Las reglas de inferencia pueden ser tan complejas que disparen el coste computacional (tiempo)

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / EL

                - Útil si se tienen muchas clases y propiedades enlazadas a través de relaciones complejas y se desea que el razonador descubra nuevas relaciones
                - Dichas relaciones entre clases pueden inferirse en tiempo polinomial

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / QL

                - Orientado hacia un procesamiento eficiente de muchos datos de tipo instancia (por ejemplo, provenientes de una BDR)
                - Está lo suficientemente limitado para poder reescribir una consulta en SQL

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  perfiles de OWL: OWL 2 / RL

                - Orientado hacia la ejecución eficiente en un motor de reglas de negocio
                - Funciona mejor con datos en RDF y reglas que podrían implementar cualquier lógica de negocio arbitraria

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases
                - Una colección de individuos
                - Una forma de describir parte del mundo
                - Ej: persona, animal, dispositivo
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                - Una colección de relaciones entre individuos
                - Una forma de describir un tipo de relación entre individuos
                - Ej: tienePadre, tieneAnimal, cumpleAños
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: individuos
                - Objetos en el mundo
                - Pertenecen a clases
                - Se relacionan con otros objetos y con valores de datos a través de propiedades
                - Ej: Miguel, AyuntamientoDeSantander, IFCA
                </script>
                </section>


                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos
                `intersectionOf`

                - Cualquier instancia de la primera **clase** lo es también de las especificadas en la lista

                        ex:Madre     owl:intersectionOf    (ex:Mujer, ex:Progenitor)
                
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (II)
                `unionOf`

                - Cualquier instancia de la primera **clase** lo es también de **al menos una** especificadas en la lista

                        ex:Progenitor     owl:unionOf    (:Madre, :Padre)
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (III)
                `complementOf`

                - La primera **clase** es equivalente a todo lo que no esté en la segunda

                        ex:Contable     owl:complementOf    ex:Incontable
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (IV)
                `disjointWith`

                - La primera **clase** y la segunda no tienen miembros en común

                        ex:Hombre     owl:disjointWith    ex:Mujer
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (V)
                `equivalentClass`

                - La primera **clase** y la segunda contienen los mismos miembros

                        ex:HijoDePedro owl:equivalentClass (:tienePadre :Pedro)
                

                ¡No implica igualdad de clases! (no denotan los mismos conceptos)
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (VI)
                `sameAs`

                - El primer **recurso** se refiere exactamente al mismo que el segundo

                        ex:Kal-El     owl:sameAs    ex:Superman
                

                Enlaza a dos individuos 
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: clases y recursos (VII)
                `differentFrom`

                - El primer **recurso** se refiere a uno distinto del segundo

                        ex:AnaPastorMinistra owl:differentFrom ex:AnaPastorPeriodista
                
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades
                `DatatypeProperty`

                - La propiedad enlaza a valores de datos simples

                        ex:cumpleaños a owl:DatatypeProperty

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (II)
                `ObjectProperty` 

                - La propiedad enlaza a otro recurso 

                        ex:tieneConyuge a owl:ObjectProperty

                enlaza a una persona (otro recurso)
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (III)
                `TransitiveProperty` 

                - Si la propiedad enlaza A con B y B con C, también enlaza A con C 

                        ex:tieneAncestro a owl:TransitiveProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (IV)
                `SymmetricProperty`

                - Si la propiedad relaciona A con B, también B con A

                        ex:tieneConyuge a owl:SymmetricProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (V)
                `AsymmetricProperty`

                - Si la propiedad relaciona A con B, nunca relaciona B con A

                        ex:tieneHijo a owl:AsymmetricProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (VI)
                `ReflexiveProperty`

                - La propiedad enlaza algo consigo mismo

                        ex:conoceA a owl:ReflexiveProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (VII)
                `IrreflexiveProperty`

                - La propiedad nunca enlaza algo consigo mismo

                        ex:tieneConyuge a owl:IrreflexiveProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (VIII)
                `FunctionalProperty`

                - La propiedad solo enlaza como mucho con un recurso

                        ex:cumpleAños a owl:FunctionalProperty
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (IX)
                `InverseFunctionalProperty`

                - El sujeto de esta propiedad se identifica unívocamente por el valor de la misma

                        ex:tieneDNI a owl:InverseFunctionalProperty
                
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (X)
                `inverseOf`

                - Las dos propiedades son inversas la una de la otra

                       ex:tieneHijo    owl:inverseOf    ex:tieneProgenitor
                
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: propiedades (DLVII)
                `equivalentProperty`

                - Las dos propiedades son exactamente las mismas, aunque tengan distinta intencionalidad

                        ex:fechaNacimiento owl:equivalentProperty ex:cumpleaños
                
                </script>
                </section>
                <section data-id="1" data-markdown style="font-size:30px;">
                <script type="text/template">
                ##  OWL: restricciones
                >Una restricción es una clase que se define por una descripción de sus miembros en términos de propiedades existentes y clases.
                `owl:onProperty` especifica qué propiedad se va a usar en la definición de la clase restricción

                Se usa la notación `[...]` para referirse a un nodo anónimo que será sujeto de todas las tripletas (una por línea, separadas por ;)
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones (II)
                `cardinality, min‑cardinality, max‑cardinality`

                - La propiedad puede tener un determinado número de valores

                        ex:Bípedo owl:equivalentClass [
                           rdf:type owl:Restriction;
                           owl:onProperty  ex:tienePiernas;
                           owl:cardinality "2"^^xsd:int
                        ]
                

                *Todos aquellos individuos que tienen 2 piernas*
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones (III)
                `hasValue`

                - Todos los objetos de la propiedad tienen el valor especificado

                        ex:HijoDePepe owl:equivalentClass [
                           rdf:type owl:Restriction;
                           owl:onProperty ex:tienePadre;
                           owl:hasValue ex:Pepe
                        ]
                

                *Todos aquellos individuos que tienen de padre a Pepe*
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones (IV)
                `someValuesFrom`

                - Al menos un objeto de esa propiedad es miembro de la clase especificada

                        ex:Progenitor owl:equivalentClass [
                           rdf:type owl:Restriction;
                           owl:onProperty ex:tieneHijo;
                           owl:someValuesFrom ex:Person
                        ].
                

                *Cualquier instancia de la clase Progenitor tiene al menos un hijo, que es instancia de la clase Persona*
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  OWL: restricciones (V)
                `allValuesFrom`

                - Todos los objetos de esa propiedad son miembros de la clase especificada

                        ex:Carnívoro owl:equivalentClass [
                             rdf:type owl:Restriction;
                             owl:onProperty  ex:come;
                             owl:allValuesFrom  ex:Carne
                        ].
                

                *La clase Carnívoro equivale a la clase de todos los individuos que comen "carne".*
                </script>
                </section>

                </section>

                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # SKOS
                Simple **Knowledge Organization System**

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción
                <!-- .slide: style="font-size:30px" -->

                ¿Qué es un KOS?

                > Un conjunto de elementos, controlados y estructurados, que pueden utilizarse para describir e indexar objetos, navegar por colecciones, etc. Se utilizan comúnmente en bibliotecas, museos y otras áreas.

                SKOS nace para permitir crear organizaciones de conocimiento modulares que puedan ser reutilizadas y referenciadas en la Web.

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción (II)

                Tipos de KOS
                - Taxonomía: la ciencia de la clasificación. Basada en relaciones jerárquicas.
                - Tesauro: extensión de una taxonomía. Añade la capacidad de hacer otras declaraciones sobre los sujetos clasificados (ej: significado, definiciones).

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS: introducción (III)

                Utilidad
                - Mayor robustez en las búsquedas (términos relacionados)
                - Ayudan a construir mejores interfaces de navegación
                - Permiten organizar formalmente el conocimiento de un dominio
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## KOS vs ontologías
                - los KOS se usan para organizar conocimiento, las ontologías para representarlo.
                - Los KOS son semánticamente mucho menos rigurosos que las ontologías.

                >Llevando los KOS a la Web Semántica se consigue hacer estos esquemas legibles por máquinas, promover la reutilización y potenciar la interoperabilidad
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS
                vocabulario RDF para representar KOS (taxonomías, tesauros, esquemas de clasificación y listas de encabezados de materia).

                        @prefix skos: <http://www.w3.org/2004/02/skos/core#> .
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: conceptos
                `skos:Concept`

                elemento fundamental del vocabulario SKOS.

                >Los conceptos son unidades de pensamiento, ideas o significados que subyacen en los sistemas de organización del conocimiento

                        ex:Animal   rdf:type    skos:Concept

                **¡Emplear URI!**

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas
                - Los conceptos se pueden caracterizar mediante etiquetas
                - Todas son subpropiedades de `rdfs:label`
                - Se usan para asociar un concepto SKOS con un literal RDF en un idioma determinado
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas (II)
                `skos:prefLabel`
                - Permite asignar una etiqueta léxica preferida a un recurso.
                - Debería contener términos usados como descriptores en sistemas de indexación
                - Se recomienda asignar etiquetas preferidas únicas
                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es.
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas (III)
                `skos:altLabel`
                - Permite asignar una etiqueta léxica alternativa a un recurso.
                - Se utiliza para representar sinónimos, abreviaturas, acrónimos...

                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es;
                          skos:altLabel     "criatura"@es.
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: etiquetas (IV)
                
                `skos:hiddenLabel`
                - Permite asignar una etiqueta léxica oculta a un recurso.
                - Se utiliza para alimentar motores de búsqueda o indexado de forma no visible.
                - Se suelen usar para incluir errores tipográficos frecuentes

                        ex:Animal
                          rdf:type          skos:Concept;
                          skos:prefLabel    "animal"@es;
                          skos:altLabel     "ganado"@es;
                          skos:hiddenLabel  "granado"@es;
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: otra caracterización
                `skos:definition`

                usada para proporcionar una explicación completa del significado de un concepto

                `skos:example, skos:scopeNote, skos:historyNote`

                todas subpropiedades de `skos:note`
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: relaciones semánticas
                >El significado de un concepto no sólo se define por las palabras en lenguaje natural almacenadas en sus etiquetas, sino por sus relaciones con otros conceptos en el vocabulario
                </script>
                </section>
                <section data-id="1" data-markdown style="font-size:30px;">
                <script type="text/template">
                ## SKOS: relaciones semánticas (II)
                `skos:broader, skos:narrower`

                usadas para representar estructura jerárquica en KOS

                - `skos:broader` se lee *tiene un concepto más amplio*
                - Rango y dominio: `skos:Concept`
                - Una es la inversa de la otra
                - **No** son transitivas (existen equivalentes transitivos)

                        ex:mamíferos rdf:type skos:Concept;
                          skos:prefLabel "mamíferos"@es;
                          skos:broader ex:animales.
                 

                 the subject of a skos:broader statement is the more specific concept involved in the assertion and its object is the more generic one.  
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: relaciones semánticas (III)
                `skos:related`

                se utiliza para relaciones asociativas no jerárquicas entre dos conceptos.

                - Es una relación simétrica
                - Rango y dominio: `skos:Concept`
                - No es transitiva
                - Es disjunta con `skos:broader,skos:narrower`

                        ex:pájaros rdf:type skos:Concept;
                          skos:prefLabel "pájaros"@es;
                          skos:related ex:ornitologia.
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: concept schemes
                `skos:ConceptScheme`

                clase que agrupa vocabularios compilados con SKOS

                        ex:tesauroAnimal rdf:type skos:ConceptScheme;
                          dct:title "Tesauro animal";
                          dct:creator ex:Pepe.
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: concept schemes (II)
                `skos:hasTopConcept`
                - Propiedad que permite enlazar un concept scheme con el resto de conceptos que contiene.
                - Dominio: `skos:ConceptScheme`
                - Rango: `skos:Concept`
                - Punto de acceso a la jerarquía de conocimiento.

                        ex:tesauroAnimal rdf:type skos:ConceptScheme;
                          skos:hasTopConcept ex:mamíferos;
                          skos:hasTopConcept ex:peces.
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: enlazado de conceptos
                `skos:closeMatch`
                - Implica que dos conceptos son lo suficientemente cercanos como para poder ser utilizados indistintamente.
                - Rango y dominio: `skos:Concept`
                - No es transitiva

                        dbpedia:Tennis rdf:type skos:ConceptScheme;
                          skos:prefLabel "tenis"@es;
                          skos:closeMatch ex2:Tenis.
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: enlazado de conceptos (II)
                `skos:exactMatch`
                - Implica que dos conceptos tienen significados equivalentes
                - Rango y dominio: `skos:Concept`
                - Sí es transitiva
                - Es un enlace más fuerte que `closeMatch`

                        ex1:animal skos:exactMatch ex2:animals.
                
                </script>
                </section>
                    
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: reutilización
                <!-- .slide: style="font-size:30px" -->
                `skos:inScheme`
                - Permite reutilizar conceptos de un esquema en otro.

                        ex1:referenceAnimalScheme rdf:type skos:ConceptScheme;
                          dct:title "Reference list of animals"@en.
                          ex1:cats rdf:type skos:Concept;
                          skos:prefLabel "cats"@en;
                          skos:inScheme ex1:referenceAnimalScheme.
                

                - La referencia a ex1:cats podría incluirse en otro esquema:

                        ex2:catScheme rdf:type skos:ConceptScheme;
                        dct:title "The Complete Cat Thesaurus"@en.
                        ex1:cats skos:inScheme ex2:catScheme.
                
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: colecciones
                `skos:Collection`
                - Permite agrupar conceptos en una colección

                        ex:Francia rdf:type skos:Concept.
                        ex:España rdf:type skos:Concept.
                        ex:Italia rdf:type skos:Concept.
                        ex:PaisesEuropeos rdf:type skos:Collection;
                          skos:member ex:Francia;
                          skos:member ex:España;
                          skos:member ex:Italia.
                

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ## SKOS: colecciones (II)
                `skos:OrderedCollection`
                - Capturan orden entre los elementos

                        ex:niños rdf:type skos:Concept.
                        ex:adolescentes rdf:type skos:Concept.
                        ex:adultos rdf:type skos:Concept.

                        _:b0 rdf:type skos:OrderedCollection;
                           skos:prefLabel "personas por grupo de edad"@en;
                           skos:memberList _:b1.
                        _:b1 rdf:first ex:niños;
                           rdf:rest _:b2.
                        _:b2 rdf:first ex:adolescentes;
                           rdf:rest _:b3.
                        _:b3 rdf:first ex:adultos;
                           rdf:rest rdf:nil.
                


                </script>
                </section>

                </section>
                <section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                # modelado de ontologías
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  clases básicas
                <!-- .slide: style="font-size:30px" -->
                - `owl:Thing`: todas las clases heredan de esta y todas las instancias lo son de ella.
                - `owl:Class`: clase de todos los recursos que son clases.
                - `owl:DatatypeProperty`: clase de todas las propiedades cuyos rangos son literales.
                - `owl:ObjectProperty`: clase de todas las propiedades cuyos rangos son instancias de `owl:Class`.
                - `rdf:XMLLiteral`: clase de todos los valores literales XML definidos en la especificación XML Schema.
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  propiedades básicas
                <!-- .slide: style="font-size:30px" -->
                - `rdf:type`: tipo de un recurso. Especifica que es una instancia de una clase.
                - `rdfs:subClassOf`: especifica que una clase es subclase de otra.
                - `rdfs:domain`: implica que, cuando una propiedad se utilice en una tripleta, el sujeto de dicha tripleta tendrá que ser instancia de la clase especificada por `rdfs:domain`
                - `rdfs:range`: implica que, cuando la propiedad se utilice en una tripleta, el objeto de dicha tripleta tendrá que ser instancia de la clase especificada por `rdfs:range`
                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                construir la ontología

                - Crear la ontología
                - Nombrar las clases y caracterizarlas
                - Nombrar las propiedades y caracterizarlas
                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                declarar hechos sobre un dominio

                - Proporcionar información sobre individuos

                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                razonar sobre hechos y ontologías

                - Determinar las consecuencias de lo construido y afirmado

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  modelado de ontologías

                herramientas: [Protégé](https://protege.stanford.edu/)
                - Editor de ontologías de código abierto
                - Marco de trabajo para construir sistemas inteligentes
                - Modular y extensible a través de plugins


                </script>
                </section>
                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  ejemplo: inferencia con Protégé

                - Celestino padre-de José Luis
                - José Luis padre-de Miguel
                - tiene-padre inversa de padre-de

                ¿qué infiere el razonador?

                </script>
                </section>

                <section data-id="1" data-markdown>
                <script type="text/template">
                ##  ejemplo: modelado SKOS

                - importar vocabulario [SKOS](http://www.w3.org/2004/02/skos/core)
                - Definir categoría, sección, subsección, dataset, serie

                </script>
                </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  ejemplo: vocabularios, skos

                            - Acceder a [punto SPARQL](http://www.icane.es/semantic-web)
                            - Lanzar consulta:
                                    construct {?s ?p ?o} where {?s a skos:Concept; ?p ?o}
                            - Acceder a [vocabulario](http://www.icane.es/opendata/vocab) e importar en Protégé
                            - Parsear RDFa en visualizador

                        </script>
                    </section>
                </section>
                <section>

                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  notación Manchester
                            ![Notación Manchester](./img/manchester.png)<!-- .element height="75%" width="75%" -->


                        </script>
                    </section>
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  classes
                            - As mentioned previously, OWL classes are interpreted as sets of individuals (or sets of objects).
                            - The class `Thing` is the class that represents the set containing all individuals. 
                            - Because of this all classes are subclasses of `Thing`.

                            All classes in Protege should start with a capital letter and should not contain spaces.



                        </script>
                    </section>
                    <section data-id="1" data-markdown style="font-size:35px;">
                        <script type="text/template">
                    ##  classes
                    >OWL Classes are assumed to `overlap`. We therefore cannot assume that an individual is not a member of a particular class simply because it has not been asserted to be a member of that class.  In order to ‘separate’ a group of classes, we must make them disjoint from one another.

                    This ensures that an individual which has been asserted to be a member of one of the classes in the group cannot be a member of any other classes in that group.
                </script>
        </section>
        <section data-id="1" data-markdown>
                <script type="text/template">
                    ##  subclasses
                    What does it actually mean to be a subclass of something in OWL?

                    In OWL, subclass means **necessary implication**: all instances of the subclass are instances of the parent class too.

        

                </script>
            </section>
            <section data-id="1" data-markdown>
                <script type="text/template">
                    ##  object properties
                  
                    >Object properties are relationships between two individuals: they link an individual to an individual.

                    Recommendations: property names start with a lower case letter, have no spaces and have the remaining words capitalised. It is also recommended that they are prefixed withthe word ‘has’, or the word ‘is’.
                </script>
            </section>

            <section data-id="1" data-markdown>
                <script type="text/template">
                    ##  functional properties
                    - If a property is functional, for a given individual, there can be at most one individual that is related to the individual via the property.
                    
                    - Functional properties are also known as single valued properties and also features.

                    - If a property is transitive then it cannot be functional.
                  
                </script>
            </section>
            <section data-id="1" data-markdown>
                <script type="text/template">
                    ##  domain and range
                    - Properties link individuals from the domain to individuals from the range.

                    - It is important to realise that in OWL domains and ranges should not be viewed as constraints to be checked. They are used as ‘axioms’ in reasoning.

                    - It is possible to specify multiple classes as the range for a property. If multiple classes are specified in Protege, the range of the property is interpreted to be the intersection of the classes.
                </script>
            </section>
            <section data-id="1" data-markdown>
                <script type="text/template">
                    ##  property restrictions
                    >A restriction describes a class of individuals based on the relationships that members of the class participate in. In other words, a restriction is a kind of class, in the same way that a named class is a kind of class.

                    i.e. The class of individuals that have `hasWheels` with a value of at least 2.
                </script>
            </section>
            <section data-id="1" data-markdown>
                <script type="text/template">
                   ##  existential restrictions
                   >Existential restrictions describe classes of individuals that participate in at least one relationship along a specified property to individuals that are members of a specified class. 
                   
                   For example, "the class of individuals that have at least one (**some**) `hasTopping` relationship to members of `MozzarellaTopping`".
                </script>
            </section>

            <section data-id="1" data-markdown>
                <script type="text/template">
                   ##  universal restrictions
                   >Universal restrictions describe classes of individuals that for a given property only have relationships along this property to individuals that are members of a specified class.
                   
                   For example, "the class of individuals that only have `hasTopping` relationships to members of `VegetableTopping`".
                </script>
            </section>

            <section data-id="1" data-markdown>
                <script type="text/template">
                   ##  necessary and sufficient conditions
                   >Necessary conditions can be read as: "If something is a member of this class then it is necessary to fulfil these conditions".  
                   
                   With necessary conditions alone, we cannot say that: "If something fulfils these conditions then it must be a member of this class"

                 
                   
                </script>
            </section>
            <section data-id="1" data-markdown>
                <script type="text/template">
                ##  necessary and sufficient conditions
                - A class that only has necessary conditions is known as a **Primitive Class**.
                - A class that has at least one set of necessary and sufficient conditions is known as a **Defined Class**.
                </script>
        </section>
        <section data-id="1" data-markdown>
                <script type="text/template">
                ##  necessary and sufficient conditions
                ><!--.element  style="font-size: 90%" -->In Protege, in order to convert necessary conditions to necessary and sufficient conditions, the conditions must be moved from under the `SubClass Of` header in the class description view to be under the `EquivalentClass` header.

                Necessary conditions are simply called `SubClasses` in Protege. Necessary and sufficient conditions are called `Equivalent classes`.
                </script>
        </section>

        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  necessary and sufficient conditions
                - To summarise: If class A is described using necessary conditions, then we can say that if an individual is a member of class A, it must satisfy the conditions.
                - We cannot say that any (random) individual that satisfies these conditions must be a member of class A.
                - However, if class A is now defined using necessary and sufficient conditions, we can say that if an individual is a member of the class A, it must satisfy the conditions and we can now say that if any (random) individual satisfies these conditions, then it must be a member of class A.
                </script>
        </section>

        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  closure axioms
                >A closure axiom on a property consists of a universal restriction that acts along the property to say that it can only be filled by the specified fillers. The restriction has a filler that is the union of the fillers that occur in the existential restrictions for the property.
                
                For example, the closure axiom on the `hasTopping` property for `MargheritaPizza` is a universal restriction that acts along the `hasTopping` property, with a filler that is the union  of `MozzarellaTopping` and also `TomatoTopping`.

                </script>
        </section>
        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  covering axioms
                >A covering axiom consists of two parts: the class that is being ‘covered’, and the classes that form the covering. 
                
                For example, suppose we have three classes A, B and C. Classes B and C are subclasses of class A. Now suppose that we have a covering axiom that specifies class A is covered by class B and also class C. This means that a member of class A must be a member of B and/or C.

                </script>
        </section>
        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  covering axioms
                >In Protege, a covering axiom manifests itself as a class that is the union of the classes being covered, which forms a superclass of the class being covered.
                
                `A SubclassOf (B or C)`

                </script>
        </section>
        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  cardinality restrictions
                > In OWL we can describe the class of individuals that have at least, at most or exactly a specified number of relationships with other individuals or datatype values. The restrictions that describe these classes are known as Cardinality Restrictions.

                
                </script>
        </section>
        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  cardinality restrictions
        
                - For a given property P, a Minimum Cardinality Restriction specifies the **minimum** number of P relationships that an individual must participate in.
                - A Maximum Cardinality Restriction specifies the **maximum** number of P relationships that an individual can participate in.
                - A Cardinality Restriction specifies the **exact** number of P relationships that an individual must participate in.
                </script>
        </section>
        <section data-id="1" data-markdown style="font-size:35px;">
                <script type="text/template">
                ##  qualified cardinality restrictions
        
                >Qualified Cardinality Restrictions (QCR) are more specific than cardinality restrictions in that they state the class of objects within the restriction.

                An unqualified cardinality restriction is exactly the same as a qualified cardinality restriction with a filler of Thing: `hasTopping min 3 Thing`
                </script>
        </section>
            
                    <section data-id="1" data-markdown>
                        <script type="text/template">
                            ##  exercise: pizza ontology
                            - [toppings](https://gist.github.com/avillar/7235b67e4eaf8edc48d5cc6ca51019f7)

                        </script>
                    </section>

                </section>
                <section data-id="1" data-markdown>
                        <script type="text/template">
                        ##  links

                           - [RDF primer](https://www.w3.org/TR/rdf11-primer/)
                           - [OWL 2 primer](https://www.w3.org/TR/owl2-primer/)
                           - [SKOS primer](https://www.w3.org/TR/skos-primer/)
                           - [Cambridge Semantics RDF](https://www.cambridgesemantics.com/blog/semantic-university/learn-rdf/)
                           - [Cambridge Semantics OWL](https://www.cambridgesemantics.com/blog/semantic-university/learn-owl-rdfs/)
                           - [Cambridge Semantics SPARQL](https://www.cambridgesemantics.com/blog/semantic-university/learn-sparql/)

                        </script>
                </section>

                <section>

                <div>
                <a href="https://masterdatascience.ifca.es/"><img alt="Logotipo Máster Data Science IFCA"  src="./img/logo_3.png" style="max-width: none; max-height: none; color: rgb(255, 153, 0);  vertical-align:middle;" /></a>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;"><a href="https://github.com/masterdatascience-uimp-uc/ontologies">Acceso al repositorio con la presentación</a></span></p>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;">URL de la presentación: <a href="https://masterdatascience-uimp-uc.github.io/ontologies/">https://masterdatascience-uimp-uc.github.io/ontologies/</a></span></p>


                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;">Alejandro Villar Fernández</span></p>
                <p style="font-size:20px; text-align:center; margin-top: 1em"><span style="font-weight: bold;"><a href="mailto:avillar@ticnor.es">avillar@ticnor.es</a></span></p>

                </div>

                </section>

				</div>

			</div>

			<script src="lib/js/head.min.js"></script>
			<script src="js/reveal.js"></script>

			<script>

				// Full list of configuration options available at:
				// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
			{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
			{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
			{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
			{ src: 'plugin/zoom-js/zoom.js', async: true },
			{ src: 'plugin/tagcloud/tagcloud.js', async: true },
			{ src: 'plugin/chalkboard/chalkboard.js' },
			{ src: 'plugin/notes/notes.js', async: true }
			],
			keyboard: {
				67: function() { RevealChalkboard.toggleNotesCanvas() },	// toggle notes canvas when 'c' is pressed
				66: function() { RevealChalkboard.toggleChalkboard() },	// toggle chalkboard when 'b' is pressed
				46: function() { RevealChalkboard.clear() },	// clear chalkboard when 'DEL' is pressed
				 8: function() { RevealChalkboard.reset() },	// reset chalkboard data on current slide when 'BACKSPACE' is pressed
				68: function() { RevealChalkboard.download() },	// downlad recorded chalkboard drawing when 'd' is pressed
			}
			});

			</script>

		</body>
	</html>
